html[data-theme="dark"] {
  --ant-primary-color: red;
  --ant-primary-color-hover: red;
  --ant-background-color: red;
  --ant-component-background: red;
  --ant-text-color: rgba(255, 255, 255, 0.85);
}

/*
 ：黑暗模式只改全局语义层，真的够吗？

  考点：黑暗模式改造深度
  高级回答：
  对绝大多数场景够用，组件层只关心语义 token。
  特殊组件如图片或插画，可以用 filter 或双资源切换处理。

  Q2：如果新增一个 Danger Button 怎么处理？
考点：可扩展性、组合逻辑
高级回答：
Danger Button 只需定义 --button-danger-bg / --button-danger-text，
状态如 :active/:disabled 可以复用全局状态规则，避免每个状态都写爆炸变量。

Q1：为什么要分三层（全局语义 / 组件语义 /状态映射）？
考点：抽象能力、可扩展性
高级回答：
分层可以保证黑暗模式只作用于全局语义层，不会影响组件本身的逻辑，
组件只依赖语义，不依赖具体颜色值，这样未来可以轻松新增主题或改色，不破坏已有组件。

Q6：如何防止硬编码颜色回流？
考点：工程治理能力
高级回答：
我会结合 grep 扫描 + Node 脚本替换 + ESLint / Stylelint 规则，
确保新增颜色都走 token，历史遗留颜色逐步替换。

Q8：切换主题会影响性能吗？
考点：浏览器渲染原理
高级回答：
CSS 变量只触发样式计算和局部重绘，不会触发布局阶段，性能开销很小。
并且限制 transition 属性范围，切换动画平滑。
*/

html[data-theme="dark"] {
  /* 1 语义层，这层 不出现组件名，只描述“视觉角色”。页面、列表、表单、按钮统统从这里“借色” */
  /*
 变量名永远描述“用途”
 不包含组件名
 数量受控（20～30 个封顶） 多了说明你在“实现层”抽象
*/
  /* Background */
  /* --color-bg-page          页面最底层背景
--color-bg-container     卡片 / 区块 
--color-bg-elevated      弹窗 / 浮层 */

  /* Text
--color-text-primary     主文案 
--color-text-secondary   次级文案 
--color-text-disabled     禁用文案 */

  /* Border / Divider 
--color-border-default
--color-border-weak*/

  /* Brand 
--color-primary
--color-danger*/

  /* 2 组件语义变量（按钮 / 输入框等 组件变量 = 页面语义变量的“映射” */
  /** button 示例 按钮不直接使用 --color-bg-page 
--btn-bg: var(--color-primary)
--btn-bg-hover
--btn-bg-active

--btn-text
--btn-text-disabled

--btn-border
--btn-border-hover*/

  /* --state-hover-opacity: 0.85;
  --state-active-opacity: 0.75;
  --state-disabled-opacity: 0.4;

  --state-disabled-bg: #f0f0f0;
  --state-disabled-text: #999999; */
  /*
    --color-bg-base: #121212;
  --color-bg-elevated: #1e1e1e;

  --color-text-primary: #e5e5e5;
  --color-text-secondary: #aaaaaa;

  --color-border-default: #333333;

  --state-disabled-bg: #2a2a2a;
  --state-disabled-text: #666666;
  */
}

/* Dark */
[data-theme="dark"] {
  --color-bg-page: #121212;
  --color-bg-container: #1e1e1e;
  --color-bg-elevated: #242424;

  --color-text-primary: rgba(255, 255, 255, 0.85);
  --color-text-secondary: rgba(255, 255, 255, 0.65);
  --color-text-tertiary: rgba(255, 255, 255, 0.45);
  --color-text-disabled: rgba(255, 255, 255, 0.25);

  --color-border-default: rgba(255, 255, 255, 0.12);
  --color-border-weak: rgba(255, 255, 255, 0.08);
  --color-border-strong: rgba(255, 255, 255, 0.2);

  --color-primary: #3c7eff;
  --color-mask: rgba(0, 0, 0, 0.65);
}

/* 
构建基于 CSS Variables 的亮 / 暗主题系统，支持页面语义色抽象、组件自动适配及图片暗黑模式处理

黑暗模式下我会先区分图片语义
UI 功能型图片会跟随主题，通常用 SVG 或双资源
内容型图片不做任何处理
避免使用 filter 反色，保证品牌和内容准确性

页面级语义色我会按背景、文字、边框、功能色来抽
它们只描述用途，不和具体组件绑定
所有组件颜色都从语义色派生
这样亮暗模式、品牌替换成本都很低 

我当时不是直接给组件写暗色样式
而是先抽了一层页面级语义颜色
组件只关心自己的语义变量
所以后面加暗黑模式和换主题都不需要改组件代码

图片我也做了区分
功能型图片会跟主题走，用 SVG 或双资源(结合媒体查询)
内容型图片完全不处理，避免反色问题
*/
